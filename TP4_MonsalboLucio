<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project>
	<configuration id="cdt.managedbuild.config.gnu.exe.debug.56851723" name="Debug">
		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
			<provider class="org.eclipse.cdt.managedbuilder.language.settings.providers.GCCBuiltinSpecsDetector" console="false" env-hash="766132112434618236" id="org.eclipse.cdt.managedbuilder.core.GCCBuiltinSpecsDetector" keep-relative-paths="false" name="CDT GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
				<language-scope id="org.eclipse.cdt.core.gcc"/>
				<language-scope id="org.eclipse.cdt.core.g++"/>
			</provider>
		</extension>
	</configuration>
	<configuration id="cdt.managedbuild.config.gnu.exe.release.2052501839" name="Release">
		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
			<provider class="org.eclipse.cdt.managedbuilder.language.settings.providers.GCCBuiltinSpecsDetector" console="false" env-hash="-1573754650162" id="org.eclipse.cdt.managedbuilder.core.GCCBuiltinSpecsDetector" keep-relative-paths="false" name="CDT GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
				<language-scope id="org.eclipse.cdt.core.gcc"/>
				<language-scope id="org.eclipse.cdt.core.g++"/>
			</provider>
		</extension>
	</configuration>
</project>
eclipse.preferences.version=1
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/CPATH/delimiter=;
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/CPATH/operation=remove
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/C_INCLUDE_PATH/delimiter=;
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/C_INCLUDE_PATH/operation=remove
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/append=true
environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.exe.debug.56851723/appendContributed=true
environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.exe.debug.56851723/LIBRARY_PATH/delimiter=;
environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.exe.debug.56851723/LIBRARY_PATH/operation=remove
environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.exe.debug.56851723/append=true
environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.exe.debug.56851723/appendContributed=true

################################################################################
# Automatically-generated file. Do not edit!
################################################################################

-include ../makefile.init

RM := rm -rf

# All of the sources participating in the build are defined here
-include sources.mk
-include testing/src/subdir.mk
-include testing/subdir.mk
-include src/subdir.mk
-include subdir.mk
-include objects.mk

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(strip $(C_DEPS)),)
-include $(C_DEPS)
endif
endif

-include ../makefile.defs

OPTIONAL_TOOL_DEPS := \
$(wildcard ../makefile.defs) \
$(wildcard ../makefile.init) \
$(wildcard ../makefile.targets) \


BUILD_ARTIFACT_NAME := likedList
BUILD_ARTIFACT_EXTENSION :=
BUILD_ARTIFACT_PREFIX :=
BUILD_ARTIFACT := $(BUILD_ARTIFACT_PREFIX)$(BUILD_ARTIFACT_NAME)$(if $(BUILD_ARTIFACT_EXTENSION),.$(BUILD_ARTIFACT_EXTENSION),)

# Add inputs and outputs from these tool invocations to the build variables 

# All Target
all: likedList

# Tool invocations
likedList: $(OBJS) $(USER_OBJS) makefile objects.mk $(OPTIONAL_TOOL_DEPS)
	@echo 'Building target: $@'
	@echo 'Invoking: GCC C Linker'
	gcc  -o "likedList" $(OBJS) $(USER_OBJS) $(LIBS)
	@echo 'Finished building target: $@'
	@echo ' '

# Other Targets
clean:
	-$(RM) $(EXECUTABLES)$(OBJS)$(C_DEPS) likedList
	-@echo ' '

.PHONY: all clean dependents

-include ../makefile.targets

################################################################################
# Automatically-generated file. Do not edit!
################################################################################

USER_OBJS :=

LIBS :=


################################################################################
# Automatically-generated file. Do not edit!
################################################################################

OBJ_SRCS := 
ASM_SRCS := 
C_SRCS := 
O_SRCS := 
S_UPPER_SRCS := 
EXECUTABLES := 
OBJS := 
C_DEPS := 

# Every subdirectory with source files must be described here
SUBDIRS := \
src \
testing/src \
testing \

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __LINKEDLIST
#define __LINKEDLIST
struct Node
{
    void* pElement;                 //puntero al elemento (persona, empleado, etc.)
    struct Node* pNextNode;         //puntero al prox nodo
}typedef Node;

struct LinkedList
{
    Node* pFirstNode;
    int size;                       //cada vez que agrego o elimino un elemento size++/--
}typedef LinkedList;
#endif



//Publicas
LinkedList* ll_newLinkedList(void);
int ll_len(LinkedList* this);                                       //devuelve el valor del campo int size
Node* test_getNode(LinkedList* this, int nodeIndex);
int test_addNode(LinkedList* this, int nodeIndex,void* pElement);
int ll_add(LinkedList* this, void* pElement);
void* ll_get(LinkedList* this, int index);
int ll_set(LinkedList* this, int index,void* pElement);
int ll_remove(LinkedList* this,int index);
int ll_clear(LinkedList* this);
int ll_deleteLinkedList(LinkedList* this);
int ll_indexOf(LinkedList* this, void* pElement);
int ll_isEmpty(LinkedList* this);
int ll_push(LinkedList* this, int index, void* pElement);
void* ll_pop(LinkedList* this,int index);                           //elimina un elemento (los enlaces a ese elemento) y devuelve un puntero a ese elemento
int ll_contains(LinkedList* this, void* pElement);
int ll_containsAll(LinkedList* this,LinkedList* this2);
LinkedList* ll_subList(LinkedList* this,int from,int to);
LinkedList* ll_clone(LinkedList* this);
int ll_sort(LinkedList* this, int (*pFunc)(void* ,void*), int order);
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../inc/LinkedList.h"


static Node* getNode(LinkedList* this, int nodeIndex);
static int addNode(LinkedList* this, int nodeIndex,void* pElement);

/** \brief Crea un nuevo LinkedList en memoria de manera dinamica
 *
 *  \param void
 *  \return LinkedList* Retorna (NULL) en el caso de no conseguir espacio en memoria
 *                      o el puntero al espacio reservado
 */
LinkedList* ll_newLinkedList(void)
{
	LinkedList* this = NULL;

	this = (LinkedList*) malloc(sizeof(LinkedList*));

	if(this!=NULL)
	{
		this->pFirstNode = NULL;
		this->size = 0;
	}

	return this;
}

/** \brief Retorna la cantidad de elementos de la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \return int Retorna (-1) si el puntero es NULL o la cantidad de elementos de la lista
 *
 */
int ll_len(LinkedList* this)
{
	int retorno = -1;
	if(this!=NULL)
	{
		retorno = this->size;
	}

	return retorno;
}


/** \brief  Obtiene un nodo de la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \param index int Indice del nodo a obtener
 * \return Node* Retorna  (NULL) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        (pNode) Si funciono correctamente
 *
 */
static Node* getNode(LinkedList* this, int nodeIndex) // nodeindex<ll_lend  nodeIndex >=0
{
	Node* pNode;// hacer con while
	int i;

	pNode = NULL;

	if(this!=NULL && nodeIndex<ll_len(this) && nodeIndex > -1)
	{
		pNode = this->pFirstNode;

		for(i = 0; i< nodeIndex; i++)
		{
			pNode = pNode->pNextNode;
		}
	}
	return pNode;
}


/** \brief  Permite realizar el test de la funcion getNode la cual es privada
 *
 * \param this LinkedList* Puntero a la lista
 * \param index int Indice del nodo a obtener
 * \return Node* Retorna  (NULL) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        (pElement) Si funciono correctamente
 *
 */
Node* test_getNode(LinkedList* this, int nodeIndex)
{
	return getNode(this, nodeIndex);
}


/** \brief Agrega y enlaza un nuevo nodo a la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion donde se agregara el nuevo nodo
 * \param pElement void* Puntero al elemento a ser contenido por el nuevo nodo
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        ( 0) Si funciono correctamente
 *
 */
static int addNode(LinkedList* this, int nodeIndex,void* pElement)
{
	int returnAux = -1;
	Node* pNodoAnterior;
	Node* pNuevoNode;

	if(this != NULL && nodeIndex >= 0 && nodeIndex <= ll_len(this))
	{
		pNuevoNode = (Node*) malloc(sizeof(Node*));// CREO ESPACIO
		if(pNuevoNode != NULL)
		{
			pNuevoNode->pElement = pElement;
			pNuevoNode->pNextNode = NULL;

			if(nodeIndex == 0)
			{
				pNuevoNode->pNextNode = this->pFirstNode; // PRIMER PUNTERO LL == NULL
				this->pFirstNode = pNuevoNode;// NODO PELEMENT Y APUNTA AL SIGUIENTE
			}else{
				pNodoAnterior = getNode(this,nodeIndex-1); // PINDE EL NODO ANTERIOR PARA LINKEAR
				pNuevoNode->pNextNode = pNodoAnterior->pNextNode;// SACA EL NULL Y APUNTA AL SIGUIENTE
				pNodoAnterior->pNextNode = pNuevoNode;
			}
			this->size++;
			returnAux = 0;
		}
	}
	return returnAux;
}

/** \brief Permite realizar el test de la funcion addNode la cual es privada
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion donde se agregara el nuevo nodo
 * \param pElement void* Puntero al elemento a ser contenido por el nuevo nodo
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        ( 0) Si funciono correctamente
 *
 */
int test_addNode(LinkedList* this, int nodeIndex,void* pElement)
{
	return addNode(this,nodeIndex,pElement);
}


/** \brief  Agrega un elemento a la lista
 * \param pList LinkedList* Puntero a la lista
 * \param pElement void* Puntero al elemento a ser agregado
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        ( 0) Si funciono correctamente
 *
 */
int ll_add(LinkedList* this, void* pElement)
{
	int retornoAux;
	int tamNode;

	retornoAux = -1;
	tamNode = ll_len(this);

	if(this!=NULL)
	{
		if(tamNode == 0)
		{
			addNode(this,0,pElement);
			retornoAux = 0;
		}else{
			addNode(this, tamNode, pElement);
			retornoAux = 0;
		}
	}
	return retornoAux;
}

/** \brief Permite realizar el test de la funcion addNode la cual es privada
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion del elemento a obtener
 * \return void* Retorna    (NULL) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                            (pElement) Si funciono correctamente
 *
 */
void* ll_get(LinkedList* this, int index)
{
	void* retornoAux;
	Node* aux;

	retornoAux = NULL;

	if(this != NULL && index<ll_len(this) && index > -1)
	{
		aux = getNode(this,index);
		if(aux != NULL)
		{
			retornoAux = aux->pElement;
		}
	}
	return retornoAux;
}


/** \brief Modifica un elemento de la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion del elemento a modificar
 * \param pElement void* Puntero al nuevo elemento
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        ( 0) Si funciono correctamente
 *
 */
int ll_set(LinkedList* this, int index,void* pElement)
{
	int retornoAux = -1;
	Node* pNode;

	if(this !=NULL && index > -1 && index < ll_len(this))
	{
		pNode = getNode(this, index);
		if(pNode != NULL)
		{
			pNode->pElement = pElement;
			retornoAux = 0;
		}
	}
	return retornoAux;
}


/** \brief Elimina un elemento de la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion del elemento a eliminar
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        ( 0) Si funciono correctamente
 *
 */
int ll_remove(LinkedList* this,int index)
{
	int retornoAux = -1;
	Node* removerNodo;
	Node* nodoPrevio;

	removerNodo = NULL;
	nodoPrevio = NULL;

	if(this != NULL && index > -1 && index < ll_len(this))
	{
		removerNodo = getNode(this, index);

		if(index == 0)
		{
			this->pFirstNode = removerNodo->pNextNode;
		}else{
			nodoPrevio = getNode(this,index - 1);
			nodoPrevio->pNextNode = removerNodo->pNextNode;
		}
		free(removerNodo);
		this->size--;
		retornoAux = 0;
	}
	return retornoAux;
}


/** \brief Elimina todos los elementos de la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        ( 0) Si funciono correctamente
 *
 */
int ll_clear(LinkedList* this)
{
	int retorno;
	int tam;

	retorno = -1;

	if(this != NULL)
	{
		tam = ll_len(this);
		do
		{
			ll_remove(this,tam);
			tam--;
		}while(this->pFirstNode != NULL);
		retorno = 0;
	}
	return retorno;
}


/** \brief Elimina todos los elementos de la lista y la lista
 *
 * \param this LinkedList* Puntero a la lista
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        ( 0) Si funciono correctamente
 *
 */
int ll_deleteLinkedList(LinkedList* this)
{
	int retorno;
	Node* pNode;
	int i;
	Node* auxiliarNodo;

	retorno = -1;

	if(this != NULL)
	{
		pNode = this->pFirstNode;
		for(i=0 ; i<this->size ; i++)			// RECORRE THIS (SIZE) VECES
		{
			if(pNode == NULL)
			{
				pNode = auxiliarNodo;
			}
			pNode = pNode->pNextNode;
			auxiliarNodo = pNode;
			free(pNode);
		}
		free(this->pFirstNode);
		retorno = 0;
	}
	return retorno;
}

/** \brief Busca el indice de la primer ocurrencia del elemento pasado como parametro
 *
 * \param this LinkedList* Puntero a la lista
 * \param pElement void* Puntero al elemento
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        (indice del elemento) Si funciono correctamente
 *
 */
int ll_indexOf(LinkedList* this, void* pElement)
{
	int retorno = -1;
	void* pAuxElement;
	int i;
	int tam;

	tam = ll_len(this);

	if(this != NULL)
	{
		for(i=0; i<tam; i++)
		{
			pAuxElement = ll_get(this, i);

			if(pAuxElement == pElement)
			{
				retorno = i;
				break;
			}
		}
	}
	return retorno;
}

/** \brief Indica si la lista esta o no vacia
 *
 * \param this LinkedList* Puntero a la lista
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        ( 0) Si la lista NO esta vacia
                        ( 1) Si la lista esta vacia
 *
 */
int ll_isEmpty(LinkedList* this)
{
	int retorno;
	int i;
	int tam;

	retorno = -1;

	if(this != NULL)
	{
		tam = ll_len(this);

		for(i=0; i<tam; i++)
		{

			if((ll_get(this, i)) == NULL)
			{
				retorno = 0;
				break;
			}
		}
		if(i == tam && retorno == -1)
		{
			retorno = 1;
		}
	}
	return retorno;
}

/** \brief Inserta un nuevo elemento en la lista en la posicion indicada
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion donde se agregara el nuevo elemento
 * \param pElement void* Puntero al nuevo elemento
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                        ( 0) Si funciono correctamente
 *
 */
int ll_push(LinkedList* this, int index, void* pElement)
{
	int retorno;

	retorno = -1;

	if(this != NULL && index >=0 && index <= ll_len(this))//valido para las 2 funciones
	{
		retorno = addNode(this,index, pElement);
	}
	return retorno;
}


/** \brief Elimina el elemento de la posicion indicada y retorna su puntero
 *
 * \param this LinkedList* Puntero a la lista
 * \param nodeIndex int Ubicacion del elemento eliminar
 * \return void* Retorna    (NULL) Error: si el puntero a la lista es NULL o (si el indice es menor a 0 o mayor al len de la lista)
                            (pElement) Si funciono correctamente
 *
 */
void* ll_pop(LinkedList* this,int index)
{
	void* retorno;
	int tam;

	retorno = NULL;
	tam = ll_len(this);

	if(this != NULL && index >= 0 && index < tam)
	{
		retorno = ll_get(this,index);
		ll_remove(this,index);
	}
	return retorno;
}

/** \brief  Determina si la lista contiene o no el elemento pasado como parametro
 *
 * \param this LinkedList* Puntero a la lista
 * \param pElement void* Puntero del elemento a verificar
 * \return int Retorna  (-1) Error: si el puntero a la lista es NULL
                        ( 1) Si contiene el elemento
                        ( 0) si No contiene el elemento
 */
int ll_contains(LinkedList* this, void* pElement)
{
	int retorno = -1;
	int i;


	if(this != NULL)
	{
		i = ll_indexOf( this, pElement);
		if(i >= 0)
		{
			retorno = 1;
		}else{
			retorno = 0;
		}
	}
	return retorno;
}

/** \brief  Determina si todos los elementos de la lista (this2)
            estan contenidos en la lista (this)
 *
 * \param this LinkedList* Puntero a la lista
 * \param this2 LinkedList* Puntero a la lista
 * \return int Retorna  (-1) Error: si alguno de los punteros a las listas son NULL
                        ( 1) Si los elementos de (this2) estan contenidos en la lista (this)
                        ( 0) si los elementos de (this2) NO estan contenidos en la lista (this)
 */
int ll_containsAll(LinkedList* this,LinkedList* this2)
{
	int retorno = -1;
	int i;
	void* elemento;
	int resultadoContain;

	if(this != NULL && this2 != NULL)
	{
		retorno = 1;
		for(i = 0; i<ll_len(this); i++)
		{
			elemento = ll_get(this2,i);

			if(elemento != NULL)
			{
				resultadoContain = ll_contains(this,elemento);
				if(resultadoContain == 0)
				{
					retorno = 0;
					break;
				}
			}
		}
	}
	return retorno;
}

/** \brief Crea y retorna una nueva lista con los elementos indicados
 *
 * \param pList LinkedList* Puntero a la lista
 * \param from int Indice desde el cual se copian los elementos en la nueva lista
 * \param to int Indice hasta el cual se copian los elementos en la nueva lista (no incluido)
 * \return LinkedList* Retorna  (NULL) Error: si el puntero a la listas es NULL
                                o (si el indice from es menor a 0 o mayor al len de la lista)
                                o (si el indice to es menor o igual a from o mayor al len de la lista)
                         (puntero a la nueva lista) Si ok
 */
LinkedList* ll_subList(LinkedList* this,int from,int to)
{
	LinkedList* cloneArray;
	int i;
	void* elemento;
	int tam;

	cloneArray = NULL;
	tam = ll_len(this);

	if(this != NULL && from >= 0 && from < to && to > from && to <= tam)
	{
		cloneArray = ll_newLinkedList();

		for(i = from ; i<to ; i++)
		{
			elemento = ll_get(this,i);
			ll_add(cloneArray, elemento);
		}
	}
	return cloneArray;
}

/** \brief Crea y retorna una nueva lista con los elementos de la lista pasada como parametro
 *
 * \param pList LinkedList* Puntero a la lista
 * \return LinkedList* Retorna  (NULL) Error: si el puntero a la listas es NULL
                                (puntero a la nueva lista) Si ok
 */
LinkedList* ll_clone(LinkedList* this)
{
	LinkedList* cloneArray;
	int tam;

	cloneArray = NULL;

	if(this != NULL)
	{
		tam = ll_len(this);
		cloneArray = ll_subList(this, 0, tam);
	}
	return cloneArray;
}


/** \brief Ordena los elementos de la lista utilizando la funcion criterio recibida como parametro
 * \param pList LinkedList* Puntero a la lista
 * \param pFunc (*pFunc) Puntero a la funcion criterio
 * \param order int  [1] Indica orden ascendente - [0] Indica orden descendente
 * \return int Retorna  (-1) Error: si el puntero a la listas es NULL
                                ( 0) Si ok
 */

int ll_sort(LinkedList* this, int (pFunc)(void* ,void*), int order)
{
	int retorno =-1;
	void* pElement1;
	void* pElement2;
	void* aux;
	int verificacion;
	int i;
	int j;
	int len;

	if(this != NULL && pFunc != NULL && order >= 0 && order <= 1)
	{
		len = ll_len(this);

		for(i=0; i<len-1; i++)
		{
			for(j=i+1; j<len; j++)
			{
				pElement1 = ll_get(this, i);
				pElement2 = ll_get(this, j);
				verificacion = pFunc(pElement1, pElement2);
				if(verificacion > 0 && order == 1)
				{
					aux = pElement1;
					pElement1 = pElement2;
					pElement2 = aux;

					ll_set(this, i, pElement1);
					ll_set(this, j, pElement2);
				}
				else
				{
					if(verificacion < 0 && order == 0)
					{
						aux = pElement2;
						pElement2 = pElement1;
						pElement1 = aux;

						ll_set(this, i, pElement1);
						ll_set(this, j, pElement2);
					}
				}
			}
		}
		retorno=0;
	}
	return retorno;
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../testing/inc/main_test.h"
#include "../inc/LinkedList.h"


int main(void)
{

	startTesting(1);  // ll_newLinkedList
	startTesting(2);  // ll_len
	startTesting(3);  // getNode - test_getNode
	startTesting(4);  // addNode - test_addNode
	startTesting(5);  // ll_add
	startTesting(6);  // ll_get
	startTesting(7);  // ll_set
	startTesting(8);  // ll_remove
	startTesting(9);  // ll_clear
	startTesting(10); // ll_deleteLinkedList
	startTesting(11); // ll_indexOf
	startTesting(12); // ll_isEmpty
	startTesting(13); // ll_push
	startTesting(14); // ll_pop
	startTesting(15); // ll_contains
	startTesting(16); // ll_containsAll
	startTesting(17); // ll_subList
	startTesting(18); // ll_clone
	startTesting(19); // ll_sort */

    return 0;
}

































/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void newTestSetup(void);
void newTestCase01(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void popTestSetup(void);
void popTestCase01(void);
void popTestCase02(void);
void popTestCase03(void);
void popTestCase04(void);
void popTestCase05(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void pushTestSetup(void);
void pushTestCase01(void);
void pushTestCase02(void);
void pushTestCase03(void);
void pushTestCase04(void);
void pushTestCase05(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void removeTestSetup(void);
void removeTestCase01(void);
void removeTestCase02(void);
void removeTestCase03(void);
void removeTestCase04(void);
void removeTestCase05(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void setTestSetup(void);
void setTestCase01(void);
void setTestCase02(void);
void setTestCase03(void);
void setTestCase04(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/



void sortTestSetup(void);
void sortTestCase01(void);
void sortTestCase02(void);
void sortTestCase03(void);
void sortTestCase04(void);
void sortTestCase05(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void subListTestSetup(void);
void subListTestCase01(void);
void subListTestCase02(void);
void subListTestCase03(void);
void subListTestCase04(void);
void subListTestCase05(void);


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void addNodeTestSetup(void);
void addNodeTestCase01(void);
void addNodeTestCase02(void);
void addNodeTestCase03(void);
void addNodeTestCase04(void);
void addNodeTestCase05(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void addTestSetup(void);
void addTestCase01(void);
void addTestCase02(void);
void addTestCase03(void);
void addTestCase04(void);


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


void clearTestSetup(void);
void clearTestCase01(void);
void clearTestCase02(void);
void clearTestCase03(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
void cloneTestSetup(void);
void cloneTestCase01(void);
void cloneTestCase02(void);
void cloneTestCase03(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
void containsAllTestSetup(void);
void containsAllTestCase01(void);
void containsAllTestCase02(void);
void containsAllTestCase03(void);
void containsAllTestCase04(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
void containsTestSetup(void);
void containsTestCase01(void);
void containsTestCase02(void);
void containsTestCase03(void);


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void deleteLinkedListTestSetup(void);
void deleteLinkedListTestCase01(void);
void deleteLinkedListTestCase02(void);



/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef __EMPLOYEE
#define __EMPLOYEE
struct
{
    int id;
    char name[51];
    char lastName[51];
    float salary;
    int sector;
    int isEmpty;

}typedef Employee;
#endif // __EMPLOYEE

int compareEmployee(void* pEmployeeA,void* pEmployeeB);
void printEmployee(Employee* p);
Employee* newEmployee(int id, char name[],char lastName[],float salary,int sector);



/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
void getNodeTestSetup(void);
void getNodeTestCase01(void);
void getNodeTestCase02(void);
void getNodeTestCase03(void);
void getNodeTestCase04(void);
void getNodeTestCase05(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
void getTestSetup(void);
void getTestCase01(void);
void getTestCase02(void);
void getTestCase03(void);
void getTestCase04(void);
void getTestCase05(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void indexOfTestSetup(void);
void indexOfTestCase01(void);
void indexOfTestCase02(void);
void indexOfTestCase03(void);




/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void isEmptyTestSetup(void);
void isEmptyTestCase01(void);
void isEmptyTestCase02(void);
void isEmptyTestCase03(void);
/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


void lenTestSetup(void);
void lenTestCase01(void);
void lenTestCase02(void);
void lenTestCase03(void);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

void startTesting(int testGroup);

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void isEmptyTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void isEmptyTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    r = ll_isEmpty(list);
    utest_assertEqualsIntMsg(r,1,"\nError en el valor de retorno de <isEmpty> si los parametros son correctos y \nla lista NO tiene elementos debe retornar 1\n");
    ll_add(list,NULL);
    r = ll_isEmpty(list);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <isEmpty> si los parametros son correctos y \nla lista tiene elementos debe retornar 0\n");

}

void isEmptyTestCase02(void)
{
    int r;
    r = ll_isEmpty(NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <isEmpty> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


void lenTestSetup(void)
{
	utest_print("Setup...\r\n");
}


void lenTestCase01(void)
{
    int r;
    LinkedList* list;

    list = ll_newLinkedList();
    list->size = 5;
    r = ll_len(list);
    utest_assertEqualsIntMsg(r,LENGTH,"\nError en el valor de retorno de <len> si los parametros son correctos\n la funcion retorna la cantidad de elementos de la lista\n");

}

void lenTestCase02(void)
{
    int r;
    LinkedList* list;
    list = ll_newLinkedList();
    r = ll_len(list);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <len> si los parametros son correctos \ny la lista esta vacia la funcion retorna 0\n");

}

void lenTestCase03(void)
{
    int r;

    r = ll_len(NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <len> si el puntero a la lista es NULL\n la funcion retorna -1\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
//**********LISTAS***********
#include "../inc/newTest.h"
#include "../inc/addTest.h"
#include "../inc/getNodeTest.h"
#include "../inc/addNodeTest.h"
//**********LISTAS***********


#include "../inc/deleteLinkedListTest.h"
#include "../inc/lenTest.h"
#include "../inc/getTest.h"
#include "../inc/containsTest.h"
#include "../inc/setTest.h"
#include "../inc/removeTest.h"
#include "../inc/clearTest.h"
#include "../inc/cloneTest.h"
#include "../inc/pushTest.h"
#include "../inc/indexOfTest.h"
#include "../inc/isEmptyTest.h"
#include "../inc/popTest.h"
#include "../inc/subListTest.h"
#include "../inc/containsAllTest.h"
#include "../inc/sortTest.h"


void startTesting(int testGroup)
{


    switch(testGroup)
    {
        case 1:
            utest_printStartTesting("ll_newLinkedList()");
            utest_init();
            utest_startTest(newTestCase01,newTestSetup,">Caso [Crear un nuevo LinkedList]");
            utest_printStatistics("ll_newLinkedList()");
            break;

        case 2:
            utest_printStartTesting("ll_len()");
            utest_init();
            utest_startTest(lenTestCase01,lenTestSetup,">Caso [Cantidad de elementos de una lista con elementos]");
            utest_startTest(lenTestCase02,lenTestSetup,">Caso [Cantidad de elementos de una lista vacia]");
            utest_startTest(lenTestCase03,lenTestSetup,">Caso [Cantidad de elementos de una lista que apunta a NULL]]");
            utest_printStatistics("ll_len()");
            break;
        case 3:
            utest_printStartTesting("ll_getNode()");
            utest_init();
            utest_startTest(getNodeTestCase01,getNodeTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(getNodeTestCase02,getNodeTestSetup,">Caso [Solicitar el primer nodo]");
            utest_startTest(getNodeTestCase03,getNodeTestSetup,">Caso [Solicitar el ultimo nodo]");
            utest_startTest(getNodeTestCase04,getNodeTestSetup,">Caso [Solicita nodo fuera de indice]");
            utest_startTest(getNodeTestCase05,getNodeTestSetup,">Caso [Solicita nodo pasando una lista NULL]");
            utest_printStatistics("ll_getNode()");
            break;
        case 4:
            utest_printStartTesting("ll_addNode()");
            utest_init();
            utest_startTest(addNodeTestCase01,addNodeTestSetup,">Caso [Verifica si se incrementa el size de la lista al agregar nodos]");
            utest_startTest(addNodeTestCase02,addNodeTestSetup,">Caso [Agregar un nuevo nodo a la lista]");
            utest_startTest(addNodeTestCase03,addNodeTestSetup,">Caso [Verificar el nodo agregado]");
            utest_startTest(addNodeTestCase04,addNodeTestSetup,">Caso [Intentar agregar nodos pasando una lista NULL]");
            utest_startTest(addNodeTestCase05,addNodeTestSetup,">Caso [Intenta agregar un nodo el la posicion cero de una lista con elementos cargados]");
            utest_printStatistics("ll_addNode()");
            break;

        case 5:
            utest_printStartTesting("ll_add()");
            utest_init();
            utest_startTest(addTestCase01,addTestSetup,">Caso [Verifica si se incrementa el size de la lista al agregar elementos]");
            utest_startTest(addTestCase02,addTestSetup,">Caso [Agregar un nuevo elemento a la lista]");
            utest_startTest(addTestCase03,addTestSetup,">Caso [Verificar el elemento agregado]");
            utest_startTest(addTestCase04,addTestSetup,">Caso [Intentar agregar elementos pasando una lista NULL]");
            utest_printStatistics("ll_add()");
            break;

        case 6:
            utest_printStartTesting("ll_get()");
            utest_init();
            utest_startTest(getTestCase01,getTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(getTestCase02,getTestSetup,">Caso [Solicitar el primer elemento]");
            utest_startTest(getTestCase03,getTestSetup,">Caso [Solicitar el ultimo elemento]");
            utest_startTest(getTestCase04,getTestSetup,">Caso [Solicita elementos fuera de indice]");
            utest_startTest(getTestCase05,getTestSetup,">Caso [Solicitar elementos pasando una lista NULL]");
            utest_printStatistics("ll_get()");
            break;

        case 7:
            utest_printStartTesting("ll_set()");
            utest_init();
            utest_startTest(setTestCase01,setTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(setTestCase02,setTestSetup,">Caso [Verifica un elemento seteado]");
            utest_startTest(setTestCase03,setTestSetup,">Caso [Intenta setear un elemento fuera de indice]");
            utest_startTest(setTestCase04,setTestSetup,">Caso [Intenta setear un elemento pasando una lista NULL]]");
            utest_printStatistics("ll_set()");
            break;

        case 8:
            utest_printStartTesting("ll_remove()");
            utest_init();
            utest_startTest(removeTestCase01,removeTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(removeTestCase02,removeTestSetup,">Caso [Verifica si un elemento fue correctamente removido]");
            utest_startTest(removeTestCase03,removeTestSetup,">Caso [Intenta remover un elemento fuera de indice]");
            utest_startTest(removeTestCase04,removeTestSetup,">Caso [Intenta remover un elemento pasando una lista NULL]]");
            utest_startTest(removeTestCase05,removeTestSetup,">Caso [Verifica el valor de pFirstNode luego de eliminar el ultimo elemento]]");
            utest_printStatistics("ll_remove()");
            break;

        case 9:
            utest_printStartTesting("ll_clear()");
            utest_init();
            utest_startTest(clearTestCase01,clearTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(clearTestCase02,clearTestSetup,">Caso [Verifica si todos los elemento fueron correctamente removidos]");
            utest_startTest(clearTestCase03,clearTestSetup,">Caso [Intenta realizar un clear pasando una lista NULL]");
            utest_printStatistics("ll_clear()");
            break;

        case 10:
            utest_printStartTesting("ll_deleteLinkedList()");
            utest_init();
            utest_startTest(deleteLinkedListTestCase01,deleteLinkedListTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(deleteLinkedListTestCase02,deleteLinkedListTestSetup,">Caso [Intenta realizar un deleteLinkedList pasando una lista NULL]]");
            utest_printStatistics("ll_deleteLinkedList()");
            break;

        case 11:
            utest_printStartTesting("ll_indexOf()");
            utest_init();
            utest_startTest(indexOfTestCase01,indexOfTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(indexOfTestCase02,indexOfTestSetup,">Caso [Intenta realizar un indexOf pasando una lista NULL]");
            utest_printStatistics("ll_indexOf()");
            break;

        case 12:
            utest_printStartTesting("ll_isEmpty()");
            utest_init();
            utest_startTest(isEmptyTestCase01,isEmptyTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(isEmptyTestCase02,isEmptyTestSetup,">Caso [Intenta realizar un isEmpty pasando una lista NULL]");
            utest_printStatistics("ll_isEmpty()");
            break;

        case 13:
            utest_printStartTesting("ll_push()");
            utest_init();
            utest_startTest(pushTestCase01,pushTestSetup,">Caso [Verifica si se incrementa el size de la lista al agregar elementos]");
            utest_startTest(pushTestCase02,pushTestSetup,">Caso [Agregar un nuevo elemento a la lista]");
            utest_startTest(pushTestCase03,pushTestSetup,">Caso [Verificar el elemento agregado]");
            utest_startTest(pushTestCase04,pushTestSetup,">Caso [Intenta insertar un elemento fuera del indice]");
            utest_startTest(pushTestCase05,pushTestSetup,">Caso [Intentar insertar elementos pasando una lista NULL]");
            utest_printStatistics("ll_push()");
            break;

        case 14:
            utest_printStartTesting("ll_pop()");
            utest_init();
            utest_startTest(popTestCase01,popTestSetup,">Caso [Verifica si se decrementa el size de la lista al quitar elementos]");
            utest_startTest(popTestCase02,popTestSetup,">Caso [Agregar un nuevo elemento a la lista]");
            utest_startTest(popTestCase03,popTestSetup,">Caso [Verificar el elemento quitado]");
            utest_startTest(popTestCase04,popTestSetup,">Caso [Intenta eliminar un elemento fuera del indice]");
            utest_startTest(popTestCase05,popTestSetup,">Caso [Intentar insertar elementos pasando una lista NULL]");
            utest_printStatistics("ll_pop()");
            break;

        case 15:
            utest_printStartTesting("ll_contains()");
            utest_init();
            utest_startTest(containsTestCase01,containsTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(containsTestCase02,containsTestSetup,">Caso [Verifica si encuentra elementos contenidos]");
            utest_startTest(containsTestCase03,containsTestSetup,">Caso [Intentar verificar si un elemento esta contenido pasando una lista NULL]");
            utest_printStatistics("ll_contains()");
            break;

        case 16:
            utest_printStartTesting("ll_containsAll()");
            utest_init();
            utest_startTest(containsAllTestCase01,containsAllTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(containsAllTestCase02,containsAllTestSetup,">Caso [Verifica el valor de retorno cuando la lista2 NO esta contenida en la lista1]");
            utest_startTest(containsAllTestCase03,containsAllTestSetup,">Caso [Verifica el valor de retorno cuando la lista2 SI esta contenida en la lista1]");
            utest_startTest(containsAllTestCase04,containsAllTestSetup,">Caso [Intentar verificar si un elemento esta contenido pasando una lista NULL]");
            utest_printStatistics("ll_containsAll()");
            break;

        case 17:
            utest_printStartTesting("ll_subList()");
            utest_init();
            utest_startTest(subListTestCase01,subListTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(subListTestCase02,subListTestSetup,">Caso [Verifica si los elementos de la sub lista son correctos]");
            utest_startTest(subListTestCase03,subListTestSetup,">Caso [Intenta generar sublistas con parametros fuera del indice]");
            utest_startTest(subListTestCase04,subListTestSetup,">Caso [Intenta crear una sublista pasando una lista NULL]");
            utest_printStatistics("ll_subList()");
            break;

        case 18:
            utest_printStartTesting("ll_clone()");
            utest_init();
            utest_startTest(cloneTestCase01,cloneTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(cloneTestCase02,cloneTestSetup,">Caso [Verifica si los elementos de la lista clonada son correctos]");
            utest_startTest(cloneTestCase03,cloneTestSetup,">Caso [Intenta crear una lista clonada pasando una lista NULL]");
            utest_printStatistics("ll_clone()");
            break;

        case 19:
            utest_printStartTesting("ll_sort()");
            utest_init();
            utest_startTest(sortTestCase01,sortTestSetup,">Caso [Verifica retorno con parametros correctos]");
            utest_startTest(sortTestCase02,sortTestSetup,">Caso [Verifica si la lista se encuentra correctamente ordenada]");
            utest_startTest(sortTestCase03,sortTestSetup,">Caso [Intenta ordenar una lista NULL]");
            utest_startTest(sortTestCase04,sortTestSetup,">Caso [Intenta ordenar pasando un puntero a la funcion criterio NULL]");
            utest_startTest(sortTestCase05,sortTestSetup,">Caso [Intenta ordenar pasando el orden fuera de valor]");
            utest_printStatistics("ll_sort()");
            break;
    }


}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"


void newTestSetup(void)
{
	utest_print("Setup...\r\n");

}

void newTestCase01(void)
{
    LinkedList* lista = ll_newLinkedList();
    utest_assertNotNullMsg(lista,"\nExiste un error. El valor de retorno no puede ser NULL\n");
}




/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void popTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void popTestCase01(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);
    list = ll_newLinkedList();
    ll_add(list,pElement2);
    pElement = ll_pop(list,0);
    utest_assertNotNullMsg(pElement,"\nError en el valor de retorno de <pop> si los parametros son correctos\n y la lista tiene el elemento solitado la funcion retorna el puntero al elemento\n");

}


void popTestCase02(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,pElement2);
    pElement = ll_pop(list,0);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <pop> al solicitar el primer elemento\n");
    utest_assertEqualsIntMsg(ll_len(list),0,"\nError en el len() de la lista luego de quitar un elemento");
}

void popTestCase03(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_add(list,pElement2);
    pElement = ll_pop(list,1);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <pop> al solicitar el ultimo elemento\n");
    utest_assertEqualsIntMsg(ll_len(list),1,"\nError en el len() de la lista luego de quitar un elemento");
}

void popTestCase04(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_add(list,pElement2);
    pElement = ll_pop(list,-1);
    utest_assertNullMsg(pElement, "\nError en el valor de retorno de <pop> al solicitar un elemento fuera de indice (< 0),\n se deberia retornar NULL\n");
    pElement = ll_pop(list,2);
    utest_assertNullMsg(pElement, "\nError en el valor de retorno de <pop> al solicitar un elemento fuera de indice (>= ll_len),\n se deberia retornar NULL\n");
}

void popTestCase05(void)
{

    utest_assertNullMsg(ll_get(NULL,0),"\nError en el valor de retorno de <get> si la lista pasada es NULL\n el valor a retornar es NULL\n");
}


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void pushTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void pushTestCase01(void)
{
    LinkedList* list;

    list = ll_newLinkedList();
    ll_push(list,0,NULL);
    utest_assertEqualsIntMsg(1,list->size,"\nError en el valor de size de la lista se debe incrementar al agregar un nuevo elemento\n");

}

void pushTestCase02(void)
{
    int i,r;
    LinkedList* list;
    Employee* pAux[LENGTH];
    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        r = ll_push(list,list->size,pAux[i]);
        utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <push> si se agrego un elemento correctamente\n el valor a retornar es (0)\n");
    }

}

void pushTestCase03(void)
{
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];
    void* pElement;
    char msg[256];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_push(list,list->size,pAux[i]);
    }

    for (i=0;i < LENGTH;i++)
    {
        pElement = ll_get(list,i);
        utest_assertNotNullMsg(pElement,"\nExiste un error al intentar obtener el elemento.\n El valor de retorno no puede ser NULL\n");
        sprintf(msg,"\nError en el valor de retorno de <get> al solicitar el elemento en la  posicion %i\n",i);
        utest_assertEqualsPointerMsg(pElement,pAux[i],msg);
    }

}

void pushTestCase04(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_push(list,-1,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <push> al intentar setear un elemento fuera de indice (< 0),\n se deberia retornar -1\n");
    r = ll_push(list,2,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <push> al intentar setear un elemento fuera de indice (>= ll_len),\n se deberia retornar -1\n");
}


void pushTestCase05(void)
{
    int r;
    r = ll_push(NULL,0,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <push> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void removeTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void removeTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_remove(list,0);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <remove> si los parametros son correctos es 0\n");
}


void removeTestCase02(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);
    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_add(list,NULL);
    ll_add(list,pElement2);
    ll_remove(list,1);
    pElement = ll_get(list,1);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <get> al solicitar \nun elemento luego de eliminar su antecesor\n");
    utest_assertEqualsIntMsg(ll_len(list),2,"\nError en el len() de la lista luego de quitar un elemento");
}

void removeTestCase03(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_remove(list,-1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <remove> al intentar eliminar un elemento fuera de indice (< 0),\n se deberia retornar -1\n");
    r = ll_remove(list,1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <remove> al intentar eliminar un elemento fuera de indice (>= ll_len),\n se deberia retornar -1\n");
}

void removeTestCase04(void)
{
    int r;
    r = ll_remove(NULL,0);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <remove> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

void removeTestCase05(void)
{
    LinkedList* list;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_remove(list,0);

    utest_assertEqualsPointerMsg(list->pFirstNode,NULL,"\nEl valor de pFirsNode luego de quitar el ultimo elemento debe ser NULL\n");

}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void setTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void setTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_set(list,0,NULL);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <set> si los parametros son correctos es 0\n");
}


void setTestCase02(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);
    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_set(list,0,pElement2);
    pElement = ll_get(list,0);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <get> al solicitar el primer elemento steado con <set>\n");

}

void setTestCase03(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_set(list,-1,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <set> al intentar setear un elemento fuera de indice (< 0),\n se deberia retornar -1\n");
    r = ll_set(list,1,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <set> al intentar setear un elemento fuera de indice (>= ll_len),\n se deberia retornar -1\n");
}

void setTestCase04(void)
{
    int r;
    r = ll_set(NULL,0,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <set> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 6


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1001,2000,1002,3000,4000,8000};
static float salarySortedUp[] = {8000,4000,3000,2000,1002,1001};
static int id[] = {11,20,3,4,9,99};


void sortTestSetup(void)
{
	utest_print("Setup...\r\n");
}


void sortTestCase01(void)
{
    int r;
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();
    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }
    r = ll_sort(list, compareEmployee,1);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <sort> si los parametros son correctos\n la funcion retorna 0\n");

}


void sortTestCase02(void)
{
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];
    Employee* pAuxGet[LENGTH];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    ll_sort(list, compareEmployee,0);

    for(i=0; i < LENGTH; i++)
    {
        pAuxGet[i] = ll_get(list,i);
        utest_assertNotNullMsg(pAuxGet[i],"Error al intentar obtener un elemento luego de ordenar");
        utest_assertEqualsFloatMsg(((Employee*)pAuxGet[i])->salary,salarySortedUp[i],"El orden de la lista es incorrecto");
    }

}
void sortTestCase03(void)
{
    int r;
    r = ll_sort(NULL, compareEmployee,1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <sort> si el puntero a la lista es NULL\n la funcion retorna -1\n");

}


void sortTestCase04(void)
{
    int r;
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();
    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }
    r = ll_sort(list, NULL,1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <sort> si el puntero a la funcion criterio es NULL\n la funcion sort retorna -1\n");

}

void sortTestCase05(void)
{
    int r;
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();
    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }
    r = ll_sort(list, compareEmployee,-1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <sort> si el orden es distinto de 1 o 0\n la funcion sort retorna -1\n");

}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void subListTestSetup(void)
{
	utest_print("Setup...\r\n");
}


void subListTestCase01(void)
{
    LinkedList* list;

    list = ll_newLinkedList();
    ll_add(list,NULL);

    utest_assertNotNullMsg(ll_subList(list,0,1),"\nError en el valor de retorno de <subList> si los parametros son correctos\nno debe retornar NULL\n");

}

void subListTestCase02(void)
{
    int i;
    LinkedList* list;
    LinkedList* pSubList;
    Employee* pAux[LENGTH];
    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    pSubList = ll_subList(list,0,2);

    for(i=0; i < 2; i++)
    {
        utest_assertEqualsPointerMsg(ll_get(pSubList,i),ll_get(list,i),"Error: la sub lista no contiene los elementos solicitados");
    }
}



void subListTestCase03(void)
{
    int i;
    LinkedList* list;
    LinkedList* pSubList;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    pSubList = ll_subList(list,-1,2);
    utest_assertNullMsg(pSubList,"\nError en el valor de retorno de <subList> el from esta fuera de indice (< 0),\n se deberia retornar NULL\n");

    pSubList = ll_subList(list,0,6);
    utest_assertNullMsg(pSubList,"\nError en el valor de retorno de <subList> el to esta fuera de indice (> len()),\n se deberia retornar NULL\n");

}

void subListTestCase04(void)
{
    int i;
    LinkedList* list;
    LinkedList* pSubList;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    pSubList = ll_subList(NULL,0,2);
    utest_assertNullMsg(pSubList,"\nError en el valor de retorno de <subList> si la lista pasada es NULL\n el valor a retornar es (NULL)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void addNodeTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void addNodeTestCase01(void)
{
    LinkedList* list;

    list = ll_newLinkedList();
    test_addNode(list,0,NULL);
    utest_assertEqualsIntMsg(1,list->size,"\nError en el valor de size de la lista se debe incrementar al agregar nodos\n");

}

void addNodeTestCase02(void)
{
    int i,r;
    LinkedList* list;
    Employee* pAux[LENGTH];
    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        r = test_addNode(list,list->size,pAux[i]);
        utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <addNode> si se agrego un nodo correctamente\n el valor a retornar es (0)\n");
    }

}

void addNodeTestCase03(void)
{
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];
    Node* nodoAux;
    char msg[256];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        test_addNode(list,list->size,pAux[i]);
    }

    for (i=0;i < LENGTH;i++)
    {
        nodoAux = test_getNode(list,i);
        utest_assertNotNullMsg(nodoAux,"\nExiste un error al intentar obtener el nodo.\n El valor de retorno no puede ser NULL\n");
        sprintf(msg,"\nError en el valor de retorno de <getNode> al solicitar el elemento en la  posicion %i\n",i);
        utest_assertEqualsPointerMsg(nodoAux->pElement,pAux[i],msg);
    }

}


void addNodeTestCase04(void)
{
    int r;
    r = test_addNode(NULL,0,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <addNode> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

void addNodeTestCase05(void)
{
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];
    Node* nodoAux;
    char msg[256];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        test_addNode(list,list->size,pAux[i]);
    }

    Employee* other = newEmployee(99,"99","99",99,99);
    test_addNode(list,0,other);

    nodoAux = test_getNode(list,0);
    utest_assertNotNullMsg(nodoAux,"\nExiste un error al intentar obtener el nodo.\n El valor de retorno no puede ser NULL\n");
    utest_assertEqualsPointerMsg(nodoAux->pElement,other,"El puntero al employee agregado en la pos 0 no corresponde\n");

    for (i=0;i < LENGTH;i++)
    {
        nodoAux = test_getNode(list,i+1);
        utest_assertNotNullMsg(nodoAux,"\nExiste un error al intentar obtener el nodo.\n El valor de retorno no puede ser NULL\n");
        sprintf(msg,"\nError en el valor de retorno de <getNode> al solicitar el elemento en la  posicion %i\n",i);
        utest_assertEqualsPointerMsg(nodoAux->pElement,pAux[i],msg);
    }
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void addTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void addTestCase01(void)
{
    LinkedList* list;

    list = ll_newLinkedList();
    ll_add(list,NULL);
    utest_assertEqualsIntMsg(1,list->size,"\nError en el valor de size de la lista se debe incrementar al agregar elementos\n");
}

void addTestCase02(void)
{
    int i,r;
    LinkedList* list;
    Employee* pAux[LENGTH];
    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        r = ll_add(list,pAux[i]);
        utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <add> si se agrego un elemento correctamente\nel valor a retornar es (0)\n");
    }

}

void addTestCase03(void)
{
    int i;
    LinkedList* list;
    Employee* pAux[LENGTH];
    Node* nodoAux;
    char msg[256];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    for (i=0;i < LENGTH;i++)
    {
        nodoAux = test_getNode(list,i);
        utest_assertNotNullMsg(nodoAux,"\nExiste un error al intentar obtener el nodo.\nEl valor de retorno no puede ser NULL\n");
        sprintf(msg,"\nError en el valor de retorno de al solicitar el elemento en la  posicion %i\n",i);
        utest_assertEqualsPointerMsg(nodoAux->pElement,pAux[i],msg);
    }

}


void addTestCase04(void)
{
    int r;
    r = ll_add(NULL,NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <add> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void clearTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void clearTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_clear(list);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <clear> si los parametros son correctos es 0\n");
}

void clearTestCase02(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);
    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_clear(list);
    ll_add(list,NULL);
    ll_add(list,pElement2);
    pElement = ll_get(list,1);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <get> al solicitar \nun elemento luego de eliminar sus antecesores con <clear>\n");
}


void clearTestCase03(void)
{
    int r;
    r = ll_clear(NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <clear> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void cloneTestSetup(void)
{
	utest_print("Setup...\r\n");
}


void cloneTestCase01(void)
{
    LinkedList* list;

    list = ll_newLinkedList();
    ll_add(list,NULL);

    utest_assertNotNullMsg(ll_clone(list),"\nError en el valor de retorno de <clone> si los parametros son correctos\nno debe retornar NULL\n");

}

void cloneTestCase02(void)
{
    int i;
    LinkedList* list;
    LinkedList* pSubList;
    Employee* pAux[LENGTH];
    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    pSubList = ll_clone(list);

    for(i=0; i < LENGTH; i++)
    {
        utest_assertEqualsPointerMsg(ll_get(pSubList,i),ll_get(list,i),"Error: la lista clonada difiere de la original");
    }
}


void cloneTestCase03(void)
{
    int i;
    LinkedList* list;
    LinkedList* pSubList;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }

    pSubList = ll_clone(NULL);
    utest_assertNullMsg(pSubList,"\nError en el valor de retorno de <clone> si la lista pasada es NULL\n el valor a retornar es (NULL)\n");
}

/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void containsAllTestSetup(void)
{
	utest_print("Setup...\r\n");
}


void containsAllTestCase01(void)
{
    int r;
    LinkedList* list;

    list = ll_newLinkedList();
    r = ll_containsAll(list,list);
    utest_assertNotEqualsIntMsg(r,-1,"\nError en el valor de retorno de <containsAll> si los parametros son correctos\n debe retornar 0 o 1\n");
}


void containsAllTestCase02(void)
{
    int i,r;
    LinkedList* list;
    LinkedList* pOtherList;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();
    pOtherList = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
        ll_add(pOtherList,pAux[i]);
    }

    ll_remove(list,0);

    r = ll_containsAll(list,pOtherList);
    utest_assertEqualsIntMsg(r, 0 ,"Error en el valor de retorno <containsAll> si la lista2 no esta contenida se debe retornar 0");


}

void containsAllTestCase03(void)
{
    int i,r;
    LinkedList* list;
    LinkedList* pOtherList;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();
    pOtherList = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
        ll_add(pOtherList,pAux[i]);
    }

    r = ll_containsAll(list,pOtherList);
    utest_assertEqualsIntMsg(r, 1 ,"Error en el valor de retorno <containsAll> si la lista2 no esta contenida se debe retornar 0");


}

void containsAllTestCase04(void)
{
    LinkedList* list;
    list = ll_newLinkedList();
    utest_assertEqualsIntMsg(ll_containsAll(list,NULL),-1,"\nError en el valor de retorno de <containsAll> si la lista (this) pasada es NULL\n el valor a retornar es -1\n");
    utest_assertEqualsIntMsg(ll_containsAll(NULL,list),-1,"\nError en el valor de retorno de <containsAll> si la lista (this2) pasada es NULL\n el valor a retornar es -1\n");
}


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST
#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

//DEFINES OF THIS TEST
#define LENGTH 5


static char* unsortedList[] = {"Za","Zb","Xd","Xb","Ya","Yc"};
static int sector[] = {1,1,2,3,4,6};
static float salary[] = {1000,1000,2000,3000,4000,8000};
static int id[] = {11,20,3,4,9,99};


void containsTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void containsTestCase01(void)
{
    int r;
    LinkedList* list;

    list = ll_newLinkedList();
    r = ll_contains(list,NULL);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <contains> si los parametros son correctos\n debe retornar 0 o 1\n");
}


void containsTestCase02(void)
{
    int i, r;
    LinkedList* list;
    Employee* pAux[LENGTH];

    list = ll_newLinkedList();

    for(i=0; i < LENGTH; i++)
    {
        pAux[i] = newEmployee(id[i],unsortedList[i],unsortedList[i],salary[i],sector[i]);
        ll_add(list,pAux[i]);
    }
    r = ll_contains(list,NULL);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <contains> si los parametros\n son correctos y NO contiene el elemento debe retornar 0\n");
    for(i=0; i < LENGTH; i++)
    {
        r = ll_contains(list,pAux[i]);
        utest_assertEqualsIntMsg(r,1,"\nError en el valor de retorno de <contains> si los parametros\n son correctos y contiene el elemento debe retornar 1\n");
    }

}

void containsTestCase03(void)
{

    utest_assertEqualsIntMsg(ll_contains(NULL,NULL),-1,"\nError en el valor de retorno de <contains> si la lista pasada es NULL\n el valor a retornar es -1\n");
}



/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void deleteLinkedListTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void deleteLinkedListTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_deleteLinkedList(list);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <deleteLinkedList> si los parametros son correctos es 0\n");
}


void deleteLinkedListTestCase02(void)
{
    int r;
    r = ll_deleteLinkedList(NULL);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <deleteLinkedList> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../inc/Employee.h"

int compareEmployee(void* pEmployeeA,void* pEmployeeB)
{

    if(((Employee*)pEmployeeA)->salary > ((Employee*)pEmployeeB)->salary)
    {
        return 1;
    }
    if(((Employee*)pEmployeeA)->salary < ((Employee*)pEmployeeB)->salary)
    {
        return -1;
    }
    return 0;


}

void printEmployee(Employee* p)
{
    printf("Nombre:%s Salario:%.2f\r\n",p->name,p->salary);
}

/** \brief Set this employee the values recived as parameters
 *
 * \param pEmployee employee*
 * \param id int
 * \param name[] char
 * \param lastName[] char
 * \param salary float
 * \param sector int
 * \return int Return (-1) if Error [NULL pointer] - (0) if Ok
 *
 */
Employee* newEmployee(int id, char name[],char lastName[],float salary,int sector)
{
    Employee* returnAux = NULL;
    Employee* pEmployee = malloc(sizeof(Employee));

    if(pEmployee != NULL)
    {
        pEmployee->id = id;
        strcpy(pEmployee->name,name);
        strcpy(pEmployee->lastName,lastName);
        pEmployee->salary = salary;
        pEmployee->sector = sector;
        pEmployee->isEmpty = 0;
        returnAux = pEmployee;
    }

    return returnAux;

}


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void getNodeTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void getNodeTestCase01(void)
{
    LinkedList* list;
    Node* nodo1;
    Node* nodo2;
    Node* nodoAux;

    list = ll_newLinkedList();
    nodo1 = malloc(sizeof(Node));
    nodo2 = malloc(sizeof(Node));
    nodo1->pNextNode = nodo2;
    nodo2->pNextNode = NULL;
    list->pFirstNode = nodo1;
    list->size=2;
    nodoAux = test_getNode(list,0);
    utest_assertNotNullMsg(nodoAux,"\nError en el valor de retorno de <getNode> si los parametros son correctos\n y la lista tiene elementos la funcion retorna el puntero al nodo\n");

}


void getNodeTestCase02(void)
{
    LinkedList* list;
    Node* nodo1;
    Node* nodo2;
    Node* nodoAux;

    list = ll_newLinkedList();
    nodo1 = malloc(sizeof(Node));
    nodo2 = malloc(sizeof(Node));
    nodo1->pNextNode = nodo2;
    nodo2->pNextNode = NULL;
    list->pFirstNode = nodo1;
    list->size=2;
    nodoAux = test_getNode(list,0);
    utest_assertEqualsPointerMsg(nodoAux,nodo1,"\nError en el valor de retorno de <getNode> al solicitar el primer elemento\n");

}

void getNodeTestCase03(void)
{
    LinkedList* list;
    Node* nodo1;
    Node* nodo2;
    Node* nodoAux;

    list = ll_newLinkedList();
    nodo1 = malloc(sizeof(Node));
    nodo2 = malloc(sizeof(Node));
    nodo1->pNextNode = nodo2;
    nodo2->pNextNode = NULL;
    list->pFirstNode = nodo1;
    list->size=2;
    nodoAux = test_getNode(list,1);
    utest_assertEqualsPointerMsg(nodoAux,nodo2,"\nError en el valor de retorno de <getNode> al solicitar el ultimo elemento\n");

}

void getNodeTestCase04(void)
{
    LinkedList* list;
    Node* nodo1;
    Node* nodo2;
    Node* nodoAux;

    list = ll_newLinkedList();
    nodo1 = malloc(sizeof(Node));
    nodo2 = malloc(sizeof(Node));
    nodo1->pNextNode = nodo2;
    nodo2->pNextNode = NULL;
    list->pFirstNode = nodo1;
    list->size=1;
    nodoAux = test_getNode(list,-1);
    utest_assertNullMsg(nodoAux, "\nError en el valor de retorno de <getNode> al solicitar un elemento fuera de indice (-1),\n se deberia retornar NULL\n");
    nodoAux = test_getNode(list,1);
    utest_assertNullMsg(nodoAux, "\nError en el valor de retorno de <getNode> al solicitar un elemento fuera de indice (>= a ll_len),\n se deberia retornar NULL\n");


}

void getNodeTestCase05(void)
{
    utest_assertNullMsg(test_getNode(NULL,0),"\nError en el valor de retorno de <get> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}


/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void getTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void getTestCase01(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);
    list = ll_newLinkedList();
    ll_add(list,pElement2);
    pElement = ll_get(list,0);
    utest_assertNotNullMsg(pElement,"\nError en el valor de retorno de <get> si los parametros son correctos\n y la lista tiene elementos la funcion retorna el puntero al elemento\n");

}


void getTestCase02(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,pElement2);
    pElement = ll_get(list,0);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <get> al solicitar el primer elemento\n");

}

void getTestCase03(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_add(list,pElement2);
    pElement = ll_get(list,1);
    utest_assertEqualsPointerMsg(pElement,pElement2,"\nError en el valor de retorno de <getNode> al solicitar el ultimo elemento\n");
}

void getTestCase04(void)
{
    LinkedList* list;
    void* pElement;
    void* pElement2 = newEmployee(10,"JUAN","PEREZ",1,1);

    list = ll_newLinkedList();
    ll_add(list,NULL);
    ll_add(list,pElement2);
    pElement = ll_get(list,-1);
    utest_assertNullMsg(pElement, "\nError en el valor de retorno de <get> al solicitar un elemento fuera de indice (< 0),\n se deberia retornar NULL\n");
    pElement = ll_get(list,2);
    utest_assertNullMsg(pElement, "\nError en el valor de retorno de <get> al solicitar un elemento fuera de indice (>= ll_len),\n se deberia retornar NULL\n");
}

void getTestCase05(void)
{

    utest_assertNullMsg(ll_get(NULL,0),"\nError en el valor de retorno de <get> si la lista pasada es NULL\n el valor a retornar es NULL\n");
}



/*
    utest example : Unit test examples.
    Copyright (C) <2018>  <Mauricio Davila>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../../testing/utest.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//INCLUDE LIBRARY TO TEST

#include "../../inc/LinkedList.h"
#include "../../testing/inc/Employee.h"

void indexOfTestSetup(void)
{
	utest_print("Setup...\r\n");
}

void indexOfTestCase01(void)
{
    LinkedList* list;
    int r;
    list = ll_newLinkedList();
    ll_add(list,NULL);
    r = ll_indexOf(list,NULL);
    utest_assertEqualsIntMsg(r,0,"\nError en el valor de retorno de <indexOf> si los parametros son correctos y \nel elemento esta contenido se debe retornar la posicion del elemento\n");
    r = ll_indexOf(list,(void*)1);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <indexOf> si los parametros son correctos y \nel elemento NO esta contenido se debe retornar -1\n");
}

void indexOfTestCase02(void)
{
    int r;
    r = ll_indexOf(NULL,0);
    utest_assertEqualsIntMsg(r,-1,"\nError en el valor de retorno de <indexOf> si la lista pasada es NULL\n el valor a retornar es (-1)\n");
}
/Debug/

<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>likedList</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
			<triggers>clean,full,incremental,</triggers>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
			<triggers>full,incremental,</triggers>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.cdt.core.cnature</nature>
		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
	</natures>
</projectDescription>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
	<storageModule moduleId="org.eclipse.cdt.core.settings">
		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.56851723">
			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.56851723" moduleId="org.eclipse.cdt.core.settings" name="Debug">
				<externalSettings/>
				<extensions>
					<extension id="org.eclipse.cdt.core.PE64" point="org.eclipse.cdt.core.BinaryParser"/>
					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
				</extensions>
			</storageModule>
			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="cdt.managedbuild.config.gnu.exe.debug.56851723" name="Debug" optionalBuildProperties="" parent="cdt.managedbuild.config.gnu.exe.debug">
					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.56851723." name="/" resourcePath="">
						<toolChain id="cdt.managedbuild.toolchain.gnu.mingw.base.1511084310" name="MinGW GCC" superClass="cdt.managedbuild.toolchain.gnu.mingw.base">
							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.PE64" id="cdt.managedbuild.target.gnu.platform.mingw.base.648274960" name="Debug Platform" osList="win32" superClass="cdt.managedbuild.target.gnu.platform.mingw.base"/>
							<builder buildPath="${workspace_loc:/likedList}/Debug" id="cdt.managedbuild.tool.gnu.builder.mingw.base.762753889" name="CDT Internal Builder.Debug" superClass="cdt.managedbuild.tool.gnu.builder.mingw.base"/>
							<tool id="cdt.managedbuild.tool.gnu.assembler.mingw.base.1528016203" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.mingw.base">
								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1610800245" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.archiver.mingw.base.1110026064" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.mingw.base"/>
							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.mingw.base.1667211693" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.mingw.base">
								<option id="gnu.cpp.compiler.option.optimization.level.84819124" superClass="gnu.cpp.compiler.option.optimization.level" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
								<option defaultValue="gnu.cpp.compiler.debugging.level.max" id="gnu.cpp.compiler.option.debugging.level.1709652718" superClass="gnu.cpp.compiler.option.debugging.level" valueType="enumerated"/>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.c.compiler.mingw.base.1696389421" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.mingw.base">
								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.option.optimization.level.369552999" superClass="gnu.c.compiler.option.optimization.level" valueType="enumerated"/>
								<option defaultValue="gnu.c.debugging.level.max" id="gnu.c.compiler.option.debugging.level.820295673" superClass="gnu.c.compiler.option.debugging.level" valueType="enumerated"/>
								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.451506122" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.c.linker.mingw.base.145998521" name="MinGW C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.mingw.base">
								<inputType id="cdt.managedbuild.tool.gnu.c.linker.input.1651378774" superClass="cdt.managedbuild.tool.gnu.c.linker.input">
									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
								</inputType>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.mingw.base.1986705948" name="MinGW C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.mingw.base"/>
						</toolChain>
					</folderInfo>
				</configuration>
			</storageModule>
			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
		</cconfiguration>
		<cconfiguration id="cdt.managedbuild.config.gnu.exe.release.2052501839">
			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.release.2052501839" moduleId="org.eclipse.cdt.core.settings" name="Release">
				<externalSettings/>
				<extensions>
					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
				</extensions>
			</storageModule>
			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.release" cleanCommand="rm -rf" description="" id="cdt.managedbuild.config.gnu.exe.release.2052501839" name="Release" parent="cdt.managedbuild.config.gnu.exe.release">
					<folderInfo id="cdt.managedbuild.config.gnu.exe.release.2052501839." name="/" resourcePath="">
						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.release.1340196133" name="Linux GCC" superClass="cdt.managedbuild.toolchain.gnu.exe.release">
							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.release.739920246" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.release"/>
							<builder buildPath="${workspace_loc:/likedList}/Release" id="cdt.managedbuild.target.gnu.builder.exe.release.542790103" managedBuildOn="true" name="Gnu Make Builder.Release" superClass="cdt.managedbuild.target.gnu.builder.exe.release"/>
							<tool id="cdt.managedbuild.tool.gnu.archiver.base.993036582" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.release.258407032" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.release">
								<option id="gnu.cpp.compiler.exe.release.option.optimization.level.906752961" superClass="gnu.cpp.compiler.exe.release.option.optimization.level" value="gnu.cpp.compiler.optimization.level.most" valueType="enumerated"/>
								<option defaultValue="gnu.cpp.compiler.debugging.level.none" id="gnu.cpp.compiler.exe.release.option.debugging.level.1992223898" superClass="gnu.cpp.compiler.exe.release.option.debugging.level" valueType="enumerated"/>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.release.922664907" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.release">
								<option defaultValue="gnu.c.optimization.level.most" id="gnu.c.compiler.exe.release.option.optimization.level.1345122204" superClass="gnu.c.compiler.exe.release.option.optimization.level" valueType="enumerated"/>
								<option defaultValue="gnu.c.debugging.level.none" id="gnu.c.compiler.exe.release.option.debugging.level.345792474" superClass="gnu.c.compiler.exe.release.option.debugging.level" valueType="enumerated"/>
								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.910452511" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.release.1959370942" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.release">
								<inputType id="cdt.managedbuild.tool.gnu.c.linker.input.603709424" superClass="cdt.managedbuild.tool.gnu.c.linker.input">
									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
								</inputType>
							</tool>
							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.release.1507449369" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.release"/>
							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.release.1044210462" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.release">
								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.527509002" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
							</tool>
						</toolChain>
					</folderInfo>
				</configuration>
			</storageModule>
			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
		</cconfiguration>
	</storageModule>
	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
		<project id="likedList.cdt.managedbuild.target.gnu.exe.1585856330" name="Executable" projectType="cdt.managedbuild.target.gnu.exe"/>
	</storageModule>
	<storageModule moduleId="scannerConfiguration">
		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.exe.debug.56851723;cdt.managedbuild.config.gnu.exe.debug.56851723.;cdt.managedbuild.tool.gnu.c.compiler.exe.debug.1293573574;cdt.managedbuild.tool.gnu.c.compiler.input.386289766">
			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
		</scannerConfigBuildInfo>
		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.exe.release.2052501839;cdt.managedbuild.config.gnu.exe.release.2052501839.;cdt.managedbuild.tool.gnu.c.compiler.exe.release.922664907;cdt.managedbuild.tool.gnu.c.compiler.input.910452511">
			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
		</scannerConfigBuildInfo>
	</storageModule>
	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
	<storageModule moduleId="refreshScope"/>
	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
</cproject>
